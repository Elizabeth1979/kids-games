<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>××©×—×§ ××œ×£-×‘×™×ª</title>
    <link rel="stylesheet" href="../styles/common.css">
    <link rel="stylesheet" href="../styles/alef-bet.css">
</head>
<body>
    <a href="../index.html" class="back-button">ğŸ  ×—×–×¨×” ×œ××©×—×§×™×</a>

    <div class="container">
        <h1>ğŸ¨ ××©×—×§ ××œ×£-×‘×™×ª ğŸ¨</h1>

        <div class="mode-selector">
            <button class="mode-btn active" onclick="setMode('learn')">ğŸ“š ×œ×•××“×™×</button>
            <button class="mode-btn" onclick="setMode('find')">ğŸ” ××¦× ××ª ×”××•×ª</button>
            <button class="mode-btn" id="shuffleBtn" onclick="toggleShuffle()">ğŸ”€ ×¢×¨×‘×‘ ××•×ª×™×•×ª</button>
        </div>

        <div class="instruction-box" id="instruction">
            ×œ×—×¥ ×¢×œ ××•×ª ×›×“×™ ×œ×©××•×¢ ××ª ×”×©× ×©×œ×”
        </div>

        <div class="score-box" id="scoreBox">
            × ×›×•×Ÿ: <span id="correct">0</span> | ×˜×¢×•×™×•×ª: <span id="wrong">0</span>
        </div>

        <div class="alef-bet-grid" id="grid"></div>

        <div class="drawing-section">
            <h2 style="color: #667eea; text-align: center; margin-bottom: 15px;">âœï¸ ×œ×•×— ×¦×™×•×¨ âœï¸</h2>
            <canvas id="drawingCanvas"></canvas>
            <div class="drawing-controls">
                <div class="control-group">
                    <label>×¦×‘×¢:</label>
                    <input type="color" id="colorPicker" value="#000000">
                </div>
                <div class="control-group">
                    <label>×¢×•×‘×™:</label>
                    <input type="range" id="brushSize" min="2" max="20" value="5">
                    <span id="sizeDisplay">5</span>
                </div>
                <button class="control-btn" onclick="clearCanvas()">ğŸ—‘ï¸ × ×§×”</button>
                <button class="control-btn" onclick="downloadDrawing()">ğŸ’¾ ×©××•×¨</button>
            </div>
        </div>

        <div class="celebration" id="celebration">ğŸ‰</div>
    </div>

    <script>
        const letters = [
            {letter: '×', name: '×Ö¸×œÖ¶×£', phonetic: 'Alef'},
            {letter: '×‘Ö¼', name: '×‘ÖµÖ¼×™×ª', phonetic: 'Bet'},
            {letter: '×‘', name: '×•Öµ×™×ª', phonetic: 'Vet'},
            {letter: '×’', name: '×’Ö´Ö¼×™×Ö¶×œ', phonetic: 'Gimel'},
            {letter: '×“', name: '×“Ö¸Ö¼×œÖ¶×ª', phonetic: 'Dalet'},
            {letter: '×”', name: '×”Öµ×', phonetic: 'Heh'},
            {letter: '×•', name: '×•Ö¸×•', phonetic: 'Vav'},
            {letter: '×–', name: '×–Ö·×™Ö´×Ÿ', phonetic: 'Zayin'},
            {letter: '×—', name: '×—Öµ×™×ª', phonetic: 'Chet'},
            {letter: '×˜', name: '×˜Öµ×™×ª', phonetic: 'Tet'},
            {letter: '×™', name: '×™×•Ö¹×“', phonetic: 'Yod'},
            {letter: '×›Ö¼', name: '×›Ö·Ö¼×£', phonetic: 'Kaf'},
            {letter: '×›', name: '×›Ö¸×£', phonetic: 'Chaf'},
            {letter: '×œ', name: '×œÖ¸×Ö¶×“', phonetic: 'Lamed'},
            {letter: '×', name: '×Öµ×', phonetic: 'Mem'},
            {letter: '× ', name: '× ×•Ö¼×Ÿ', phonetic: 'Nun'},
            {letter: '×¡', name: '×¡Ö¸×Ö¶×šÖ°', phonetic: 'Samech'},
            {letter: '×¢', name: '×¢Ö·×™Ö´×Ÿ', phonetic: 'Ayin'},
            {letter: '×¤Ö¼', name: '×¤ÖµÖ¼×', phonetic: 'Peh'},
            {letter: '×¤', name: '×¤Öµ×', phonetic: 'Feh'},
            {letter: '×¦', name: '×¦Ö·×“Ö´Ö¼×™', phonetic: 'Tzadi'},
            {letter: '×§', name: '×§×•Ö¹×£', phonetic: 'Kuf'},
            {letter: '×¨', name: '×¨Öµ×™×©×', phonetic: 'Resh'},
            {letter: '×©×', name: '×©Ö´××™×Ÿ', phonetic: 'Shin'},
            {letter: '×©×‚', name: '×©Ö´×‚×™×Ÿ', phonetic: 'Sin'},
            {letter: '×ª', name: '×ªÖ¸Ö¼×•', phonetic: 'Tav'},
            {letter: '×š', name: '×›Ö·Ö¼×£ ×¡×•Ö¹×¤Ö´×™×ª', phonetic: 'Chaf Sofit'},
            {letter: '×', name: '×Öµ× ×¡×•Ö¹×¤Ö´×™×ª', phonetic: 'Mem Sofit'},
            {letter: '×Ÿ', name: '× ×•Ö¼×Ÿ ×¡×•Ö¹×¤Ö´×™×ª', phonetic: 'Nun Sofit'},
            {letter: '×£', name: '×¤ÖµÖ¼× ×¡×•Ö¹×¤Ö´×™×ª', phonetic: 'Feh Sofit'},
            {letter: '×¥', name: '×¦Ö·×“Ö´Ö¼×™ ×¡×•Ö¹×¤Ö´×™×ª', phonetic: 'Tzadi Sofit'}
        ];

        const colors = [
            '#FF6B6B', '#4ECDC4', '#45B7D1', '#FFA07A', '#98D8C8',
            '#F7DC6F', '#BB8FCE', '#85C1E2', '#F8B739', '#52B788',
            '#FFB6C1', '#87CEEB', '#DDA15E', '#B4A7D6', '#F4A261',
            '#E76F51', '#2A9D8F', '#E9C46A', '#F07167', '#00B4D8',
            '#90E0EF', '#CAF0F8', '#FF8FA3', '#C9ADA7', '#A8DADC',
            '#F1FAEE', '#E63946', '#FFD93D', '#6BCF7F', '#A78BFA',
            '#FB923C'
        ];

        let currentMode = 'learn';
        let currentTarget = null;
        let correctCount = 0;
        let wrongCount = 0;
        let currentLetters = [...letters];
        let isShuffled = false;

        const grid = document.getElementById('grid');
        const instruction = document.getElementById('instruction');
        const scoreBox = document.getElementById('scoreBox');
        const celebration = document.getElementById('celebration');
        const shuffleBtn = document.getElementById('shuffleBtn');

        // Canvas setup
        const canvas = document.getElementById('drawingCanvas');
        const ctx = canvas.getContext('2d');
        const colorPicker = document.getElementById('colorPicker');
        const brushSize = document.getElementById('brushSize');
        const sizeDisplay = document.getElementById('sizeDisplay');

        let isDrawing = false;
        let lastX = 0;
        let lastY = 0;

        // Set canvas size
        function resizeCanvas() {
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width;
            canvas.height = rect.height;
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }

        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Drawing functions
        function startDrawing(e) {
            isDrawing = true;
            const rect = canvas.getBoundingClientRect();
            const x = (e.clientX || e.touches[0].clientX) - rect.left;
            const y = (e.clientY || e.touches[0].clientY) - rect.top;
            lastX = x * (canvas.width / rect.width);
            lastY = y * (canvas.height / rect.height);
        }

        function draw(e) {
            if (!isDrawing) return;
            e.preventDefault();

            const rect = canvas.getBoundingClientRect();
            const x = (e.clientX || e.touches[0].clientX) - rect.left;
            const y = (e.clientY || e.touches[0].clientY) - rect.top;
            const canvasX = x * (canvas.width / rect.width);
            const canvasY = y * (canvas.height / rect.height);

            ctx.beginPath();
            ctx.moveTo(lastX, lastY);
            ctx.lineTo(canvasX, canvasY);
            ctx.strokeStyle = colorPicker.value;
            ctx.lineWidth = brushSize.value;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.stroke();

            lastX = canvasX;
            lastY = canvasY;
        }

        function stopDrawing() {
            isDrawing = false;
        }

        canvas.addEventListener('mousedown', startDrawing);
        canvas.addEventListener('mousemove', draw);
        canvas.addEventListener('mouseup', stopDrawing);
        canvas.addEventListener('mouseout', stopDrawing);

        canvas.addEventListener('touchstart', startDrawing);
        canvas.addEventListener('touchmove', draw);
        canvas.addEventListener('touchend', stopDrawing);

        brushSize.addEventListener('input', (e) => {
            sizeDisplay.textContent = e.target.value;
        });

        function clearCanvas() {
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }

        function downloadDrawing() {
            const link = document.createElement('a');
            link.download = 'drawing.png';
            link.href = canvas.toDataURL();
            link.click();
        }

        function shuffleArray(array) {
            const newArray = [...array];
            for (let i = newArray.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [newArray[i], newArray[j]] = [newArray[j], newArray[i]];
            }
            return newArray;
        }

        function toggleShuffle() {
            isShuffled = !isShuffled;

            if (isShuffled) {
                currentLetters = shuffleArray(letters);
                shuffleBtn.style.background = '#FF9800';
                shuffleBtn.style.color = 'white';
                speak('×”××•×ª×™×•×ª ××¢×•×¨×‘×‘×•×ª');
            } else {
                currentLetters = [...letters];
                shuffleBtn.style.background = '';
                shuffleBtn.style.color = '';
                speak('×—×–×¨×” ×œ×¡×“×¨ ×¨×’×™×œ');
            }

            createGrid();
        }

        function createGrid() {
            grid.innerHTML = '';
            currentLetters.forEach((item, index) => {
                const box = document.createElement('div');
                box.className = 'letter-box';

                const letterSpan = document.createElement('div');
                letterSpan.textContent = item.letter;

                const phoneticSpan = document.createElement('div');
                phoneticSpan.className = 'phonetic';
                phoneticSpan.textContent = item.phonetic;

                box.appendChild(letterSpan);
                box.appendChild(phoneticSpan);

                box.style.backgroundColor = colors[letters.indexOf(item)];
                box.onclick = () => handleLetterClick(item);
                grid.appendChild(box);
            });
        }

        function speak(text) {
            const utterance = new SpeechSynthesisUtterance(text);
            utterance.lang = 'he-IL';
            utterance.rate = 0.8;
            speechSynthesis.cancel();
            speechSynthesis.speak(utterance);
        }

        function setMode(mode) {
            currentMode = mode;
            correctCount = 0;
            wrongCount = 0;
            updateScore();

            document.querySelectorAll('.mode-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');

            document.querySelectorAll('.letter-box').forEach(box => {
                box.classList.remove('correct', 'wrong', 'highlight');
            });

            if (mode === 'learn') {
                instruction.textContent = '×œ×—×¥ ×¢×œ ××•×ª ×›×“×™ ×œ×©××•×¢ ××ª ×”×©× ×©×œ×”';
                scoreBox.classList.remove('show');
            } else if (mode === 'find') {
                scoreBox.classList.add('show');
                nextFindChallenge();
            }
        }

        function nextFindChallenge() {
            currentTarget = letters[Math.floor(Math.random() * letters.length)];
            instruction.innerHTML = `××¦× ××ª ×”××•×ª <span style="color: #FFD93D; font-size: 1.3em;">${currentTarget.letter}</span>`;
            speak('××¦× ××ª ×”××•×ª ' + currentTarget.name);
        }

        function handleLetterClick(item) {
            if (currentMode === 'learn') {
                speak(item.name);
                const box = event.target;
                box.style.transform = 'scale(1.2)';
                setTimeout(() => {
                    box.style.transform = '';
                }, 300);
            } else if (currentMode === 'find') {
                if (item.letter === currentTarget.letter) {
                    handleCorrect();
                } else {
                    handleWrong();
                }
            }
        }

        function handleCorrect() {
            correctCount++;
            updateScore();
            speak('×›×œ ×”×›×‘×•×“! × ×›×•×Ÿ!');

            const box = event.target;
            box.classList.add('correct');

            celebration.textContent = ['ğŸ‰', 'â­', 'ğŸŒŸ', 'âœ¨', 'ğŸŠ'][Math.floor(Math.random() * 5)];
            celebration.style.display = 'block';

            setTimeout(() => {
                celebration.style.display = 'none';
                box.classList.remove('correct');
                nextFindChallenge();
            }, 1500);
        }

        function handleWrong() {
            wrongCount++;
            updateScore();
            speak('× ×¡×” ×©×•×‘');

            const box = event.target;
            box.classList.add('wrong');

            setTimeout(() => {
                box.classList.remove('wrong');
            }, 600);
        }

        function updateScore() {
            document.getElementById('correct').textContent = correctCount;
            document.getElementById('wrong').textContent = wrongCount;
        }

        createGrid();
    </script>
</body>
</html>
